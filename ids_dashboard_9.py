# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i1C7_bWn96yJi0kvLywZqG04igR8CNqP
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

from sklearn.ensemble import RandomForestClassifier, IsolationForest
from sklearn.metrics import (
    roc_auc_score, f1_score, confusion_matrix, roc_curve
)
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder

# ----------------- Page Setup -----------------
st.set_page_config(
    page_title="CICIDS2017 IDS Dashboard",
    layout="wide",
    initial_sidebar_state="expanded"
)
st.title("üîç CICIDS2017 IDS Dashboard ‚Äî DoS/DDoS Detection")
st.caption("Train & compare IsolationForest vs RandomForest on uploaded dataset")

# ----------------- Sidebar -----------------
with st.sidebar:
    st.header("‚öôÔ∏è Options")
    model_choice = st.radio(
        "Select Mode",
        ["IsolationForest", "RandomForest", "Comparison"],
        index=0
    )
    uploaded_file = st.file_uploader("üìÇ Upload CSV Dataset", type=["csv"])
    download_btn_placeholder = st.empty()

# ----------------- Helper Functions -----------------
@st.cache_data
def preprocess_data(df):
    df = df.dropna()

    # Detect label column robustly
    label_col = [c for c in df.columns if c.strip().lower() == "label"]
    if not label_col:
        return None, df
    label_col = label_col[0]

    le = LabelEncoder()
    df[label_col] = le.fit_transform(df[label_col])
    return label_col, df

def train_random_forest(X_train, y_train, X_test, y_test):
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    y_proba = model.predict_proba(X_test)[:, 1]
    return evaluate_model("RandomForest", y_test, y_pred, y_proba)

def train_isolation_forest(X_train, y_train, X_test, y_test):
    model = IsolationForest(contamination=0.1, random_state=42)
    model.fit(X_train)
    y_pred = model.predict(X_test)
    y_pred = np.where(y_pred == -1, 1, 0)  # anomaly = 1, benign = 0

    # Use decision_function scores for ROC
    scores = -model.decision_function(X_test)
    return evaluate_model("IsolationForest", y_test, y_pred, scores)

def evaluate_model(name, y_true, y_pred, y_proba):
    roc_auc = (
        roc_auc_score(y_true, y_proba)
        if y_proba is not None and len(np.unique(y_proba)) > 1
        else 0.0
    )
    f1_attack = f1_score(y_true, y_pred, pos_label=1, zero_division=0)
    f1_benign = f1_score(y_true, y_pred, pos_label=0, zero_division=0)
    cm = confusion_matrix(y_true, y_pred)

    # Confusion Matrix Plot
    fig_cm, ax = plt.subplots()
    sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", ax=ax)
    ax.set_title(f"{name} Confusion Matrix")
    ax.set_xlabel("Predicted")
    ax.set_ylabel("True")

    # ROC Curve
    fig_roc, ax = plt.subplots()
    if y_proba is not None and len(np.unique(y_proba)) > 1:
        fpr, tpr, _ = roc_curve(y_true, y_proba)
        ax.plot(fpr, tpr, label=f"{name} (AUC={roc_auc:.2f})")
        ax.plot([0, 1], [0, 1], "k--")
        ax.legend()
    ax.set_title(f"{name} ROC Curve")

    return {
        "roc_auc": roc_auc,
        "f1_attack": f1_attack,
        "f1_benign": f1_benign,
        "y_pred": y_pred,
        "cm": fig_cm,
        "roc": fig_roc,
    }

# ----------------- Main Logic -----------------
if uploaded_file is not None:
    df = pd.read_csv(uploaded_file)

    label_col, df = preprocess_data(df)
    if label_col is None:
        st.error("‚ùå Dataset must contain a 'Label' column.")
        st.stop()

    X = df.drop(columns=[label_col])
    y = df[label_col]

    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.3, random_state=42
    )

    results = {}

    if model_choice in ["RandomForest", "Comparison"]:
        results["rf"] = train_random_forest(X_train, y_train, X_test, y_test)

    if model_choice in ["IsolationForest", "Comparison"]:
        results["iso"] = train_isolation_forest(X_train, y_train, X_test, y_test)

    # ----------------- Metrics Row -----------------
    st.markdown("### üìä Model Metrics")
    cols = st.columns(4)
    if model_choice != "Comparison":
        res = results["rf"] if model_choice == "RandomForest" else results["iso"]
        cols[0].metric("ROC-AUC", f"{res['roc_auc']:.3f}")
        cols[1].metric("F1 Attack", f"{res['f1_attack']:.3f}")
        cols[2].metric("F1 Benign", f"{res['f1_benign']:.3f}")
        cols[3].metric("Samples", f"{len(y_test):,}")
    else:
        cols[0].metric("RF ROC-AUC", f"{results['rf']['roc_auc']:.3f}")
        cols[1].metric("RF F1 Attack", f"{results['rf']['f1_attack']:.3f}")
        cols[2].metric("ISO F1 Attack", f"{results['iso']['f1_attack']:.3f}")
        cols[3].metric("Samples", f"{len(y_test):,}")

    # ----------------- Graphs Section -----------------
    st.markdown("### üìà Model Visuals")

    if model_choice == "Comparison":
        tab1, tab2 = st.tabs(["RandomForest", "IsolationForest"])
        with tab1:
            c1, c2 = st.columns(2)
            with c1: st.pyplot(results["rf"]["cm"])
            with c2: st.pyplot(results["rf"]["roc"])
        with tab2:
            c1, c2 = st.columns(2)
            with c1: st.pyplot(results["iso"]["cm"])
            with c2: st.pyplot(results["iso"]["roc"])
    else:
        res = results["rf"] if model_choice == "RandomForest" else results["iso"]
        c1, c2 = st.columns(2)
        with c1: st.pyplot(res["cm"])
        with c2: st.pyplot(res["roc"])

    # ----------------- Predictions Table -----------------
    st.markdown("---")
    st.subheader("üìã Predictions Table")
    df_preds = X_test.copy()
    df_preds["True Label"] = y_test
    df_preds["Predicted"] = res["y_pred"] if model_choice != "Comparison" else results["rf"]["y_pred"]

    st.dataframe(df_preds.head(2000), use_container_width=True, height=400)

    # ----------------- Pie Chart -----------------
    st.subheader("Attack vs Benign (Predicted)")
    pie = px.pie(df_preds, names=df_preds["Predicted"].map({0: "Benign", 1: "Attack"}))
    st.plotly_chart(pie, use_container_width=True)

    # ----------------- Download Button -----------------
    csv = df_preds.to_csv(index=False).encode("utf-8")
    download_btn_placeholder.download_button(
        "‚¨áÔ∏è Download Predictions CSV",
        data=csv,
        file_name="predictions.csv",
        mime="text/csv",
    )
else:
    st.info("üëÜ Please upload a dataset to get started.")