# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VtBblDxy1xceoepXTUZVzZGNeSmpZLZS
"""

import os
import joblib
import numpy as np
import pandas as pd
import streamlit as st
import plotly.express as px
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, label_binarize
from sklearn.ensemble import IsolationForest, RandomForestClassifier
from sklearn.metrics import (
    classification_report, roc_auc_score, confusion_matrix, roc_curve
)

# -----------------------------
# Streamlit Page Config
# -----------------------------
st.set_page_config(page_title="CICIDS2017 IDS Dashboard", layout="wide")

st.title("üîç CICIDS2017 Intrusion Detection System Dashboard")

# -----------------------------
# File Upload
# -----------------------------
uploaded_file = st.file_uploader("Upload a CSV file", type=["csv"])

if uploaded_file is not None:
    df = pd.read_csv(uploaded_file)
    st.success(f"‚úÖ Loaded dataset with {df.shape[0]:,} rows and {df.shape[1]} columns")

    st.subheader("üìä Dataset Preview")
    st.dataframe(df.head())

    # -----------------------------
    # Preprocessing
    # -----------------------------
    target_col = st.selectbox("Select Target Column (Attack/Normal labels)", df.columns)

    X = df.drop(columns=[target_col])
    y = df[target_col]

    X = X.select_dtypes(include=[np.number]).fillna(0)

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    # -----------------------------
    # Train-Test Split
    # -----------------------------
    X_train, X_test, y_train, y_test = train_test_split(
        X_scaled, y, test_size=0.3, random_state=42, stratify=y
    )

    # -----------------------------
    # Random Forest (Supervised)
    # -----------------------------
    rf = RandomForestClassifier(n_estimators=100, random_state=42)
    rf.fit(X_train, y_train)

    y_pred_rf = rf.predict(X_test)
    y_prob_rf = rf.predict_proba(X_test)

    # Multi-class safe ROC AUC
    if len(np.unique(y_test)) > 2:
        y_test_bin = label_binarize(y_test, classes=np.unique(y_test))
        auc_rf = roc_auc_score(y_test_bin, y_prob_rf, multi_class="ovr")
    else:
        auc_rf = roc_auc_score(y_test, y_prob_rf[:, 1])

    # -----------------------------
    # Isolation Forest (Unsupervised)
    # -----------------------------
    iso = IsolationForest(contamination=0.05, random_state=42)
    iso.fit(X_train)

    y_pred_iso = iso.predict(X_test)
    y_pred_iso = np.where(y_pred_iso == -1, "Attack", "Normal")

    # -----------------------------
    # Results Display
    # -----------------------------
    st.subheader("üìà Random Forest Results")
    st.text(classification_report(y_test, y_pred_rf))
    st.write("ROC-AUC Score:", auc_rf)

    st.subheader("üìâ Isolation Forest Results")
    st.text(classification_report(y_test, y_pred_iso))

    # -----------------------------
    # Confusion Matrix - RF
    # -----------------------------
    cm = confusion_matrix(y_test, y_pred_rf)
    fig_cm = px.imshow(cm, text_auto=True, title="Confusion Matrix - Random Forest")
    st.plotly_chart(fig_cm, use_container_width=True)

    # -----------------------------
    # ROC Curve - RF
    # -----------------------------
    st.subheader("ROC Curve - Random Forest")
    fig, ax = plt.subplots()

    if len(np.unique(y_test)) > 2:
        # Multi-class ROC curves
        y_test_bin = label_binarize(y_test, classes=np.unique(y_test))
        for i, class_label in enumerate(np.unique(y_test)):
            fpr, tpr, _ = roc_curve(y_test_bin[:, i], y_prob_rf[:, i])
            ax.plot(fpr, tpr, label=f"{class_label}")
    else:
        fpr, tpr, _ = roc_curve(y_test, y_prob_rf[:, 1])
        ax.plot(fpr, tpr, label="Random Forest")

    ax.plot([0, 1], [0, 1], "k--")
    ax.set_xlabel("False Positive Rate")
    ax.set_ylabel("True Positive Rate")
    ax.set_title("ROC Curve")
    ax.legend()
    st.pyplot(fig)

    # -----------------------------
    # Download Predictions
    # -----------------------------
    st.subheader("‚¨áÔ∏è Download Predictions")
    pred_df = pd.DataFrame({
        "Actual": y_test,
        "RF_Prediction": y_pred_rf,
        "ISO_Prediction": y_pred_iso
    })

    csv = pred_df.to_csv(index=False).encode("utf-8")
    st.download_button(
        label="Download Predictions as CSV",
        data=csv,
        file_name="predictions.csv",
        mime="text/csv",
    )

else:
    st.info("üëÜ Please upload a dataset to begin.")